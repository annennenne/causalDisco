% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knowledge.R
\name{knowledge}
\alias{knowledge}
\title{Knowledge Mini-DSL Constructor}
\usage{
knowledge(...)
}
\arguments{
\item{...}{Arguments to define the knowledge object:
\itemize{
\item Optionally, a single data frame (first argument) whose column names
initialize and freeze the variable set.
\item Zero or more mini-DSL calls:
\code{tier()}, \code{exogenous()}, \code{exo()}, or infix operators \verb{\%-->\%}, \verb{\%!-->\%}.
\itemize{
\item \code{tier()}: One or more two-sided formulas (\code{tier(1 ~ x + y)}), or a numeric vector.
\item \code{exogenous()} / \code{exo()}: Variable names or tidyselect selectors.
Arguments are evaluated in order; only these calls are allowed.
}
}}
}
\value{
A populated \code{knowledge} object.
}
\description{
Constructs a \code{knowledge} object optionally initialized with a data frame and
extended with variable relationships expressed via formulas, selectors, or infix operators:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{tier(1 ~ V1 + V2, exposure ~ E)
V1 \%-->\% V3    # infix syntax for required edge from V1 to V3
V2 \%!-->\% V3    # infix syntax for an edge from V2 to V3 that is forbidden
exogenous(V1, V2)
}\if{html}{\out{</div>}}
}
\details{
Create a \code{knowledge} object using a concise mini-DSL with \code{tier()}, \code{exogenous()} and infix edge operators
\verb{\%-->\%} and \verb{\%!-->\%}.

The first argument can be a data frame, which will be used to populate the
\code{knowledge} object with variable names. If you later add variables with
add_* verbs, this will throw a warning, since the knowledge object will
be \emph{frozen}. You can unfreeze a knowledge object by using the function
\code{unfreeze(knowledge)}.

If no data frame is provided, the object is initially empty. Variables can
then be added via \code{tier()}, \code{forbidden()}, \code{required()}, infix operators, or \code{add_vars()}.
\itemize{
\item \code{tier()}: Assigns variables to tiers. Tiers may be numeric or string labels.
The left-hand side (LHS) of the formula is the tier; the right-hand side (RHS)
specifies variables. Variables can also be selected using tidyselect syntax:
\code{tier(1 ~ starts_with("V"))}.
\item \verb{\%-->\%} and \verb{\%!-->\%}: Infix operators to define required and forbidden edges, respectively.
Both sides of the operator can use tidyselect syntax to select multiple variables.
\item \code{exogenous()} / \code{exo()}: Mark variables as exogenous.
\item Numeric vector shortcut for \code{tier()}:
\code{tier(c(1, 2, 1))} assigns tiers by index to all existing variables.
}
}
\examples{
### knowledge() example ###

data(tpc_example)

# knowledge objects are made with the knowledge() function
kn <- knowledge()


# knowledge objects contain tier information, forbidden and required edges
kn <- knowledge(
  tier(
    1 ~ V1 + V2,
    2 ~ V3
  ),
  V1 \%-->\% V2,
  V3 \%!-->\% V1
)

# if a data frame is provided, variable names are checked against it
kn <- knowledge(
  tpc_example,
  tier(
    1 ~ child_x1 + child_x2,
    2 ~ youth_x3 + youth_x4,
    3 ~ oldage_x5 + oldage_x6
  )
)

# throws error
try(
  knowledge(
    tpc_example,
    tier(
      1 ~ child_x1 + child_x2,
      2 ~ youth_x3 + youth_x4,
      3 ~ oldage_x5 + woops
    ) # wrong name
  )
)

# using tidyselect helpers
kn <- knowledge(
  tpc_example,
  tier(
    1 ~ starts_with("child"), # can use tidyselect helpers
    2 ~ youth_x3 + youth_x4, # do not need quotes for tiers or variables
    3 ~ starts_with("oldage")
  ) # doesn't have to match data naming
)

# custom tier naming
kn <- knowledge(
  tpc_example,
  tier(
    "child" ~ starts_with("child"), # can use tidyselect helpers
    youth ~ starts_with("youth"), # do not need quotes for tiers
    elderly ~ starts_with("oldage")
  ) # doesn't have to match data naming
)

# There is also required and forbidden edges, which are specified like so
kn <- knowledge(
  tpc_example,
  child_x1 \%-->\% youth_x3,
  oldage_x6 \%!-->\% child_x1
)

# You can also add exogenous variables
kn <- knowledge(
  tpc_example,
  exogenous(child_x1),
  exo(child_x2) # shorthand
)

# You can also build knowledge with a verb pipeline
kn <-
  knowledge() |>
  add_vars(c("A", "B", "C", "D")) |> # knowledge now only takes these variables
  add_tier(One) |>
  add_to_tier("One" ~ A + B) |>
  add_tier(2, after = One) |>
  add_to_tier(2 ~ C + D) |>
  forbid_edge("A" ~ C) |>
  require_edge(A ~ B)

# Mix DSL start + verb refinement
kn <-
  knowledge(
    tier(1 ~ V5, 2 ~ V6),
    forbidden(V5 ~ V6)
  ) |>
  add_tier(3, after = "2") |>
  add_to_tier(3 ~ V7) |>
  add_exo(V2) |>
  add_exogenous(V3)

# Using seq_tiers for larger datasets
tpc_example <- as.data.frame(
  matrix(
    runif(100), # 100 random numbers in (0,1)
    nrow = 1,
    ncol = 100,
    byrow = TRUE
  )
)

names(tpc_example) <- paste0("X_", 1:100) # label the columns X_1,..., X_100

kn <- knowledge(
  tpc_example,
  tier(
    seq_tiers(
      1:100,
      ends_with("_{i}")
    )
  ),
  X_1 \%-->\% X_2
)

tpc_example <- data.frame(
  X_1 = 1,
  X_2 = 2,
  tier3_A = 3,
  Y5_ok = 4,
  check.names = FALSE
)

kn_seq_tiers2 <- knowledge(
  tpc_example,
  tier(
    seq_tiers(1:2, ends_with("_{i}")), # X_1, X_2
    seq_tiers(3, starts_with("tier{i}")), # tier3_
    seq_tiers(5, matches("Y{i}_ok")) # exact match
  )
)
}
\seealso{
Other knowledge functions: 
\code{\link{+.knowledge}()},
\code{\link{add_exogenous}()},
\code{\link{add_tier}()},
\code{\link{add_to_tier}()},
\code{\link{add_vars}()},
\code{\link{as_bnlearn_knowledge}()},
\code{\link{as_pcalg_constraints}()},
\code{\link{as_tetrad_knowledge}()},
\code{\link{deparse_knowledge}()},
\code{\link{forbid_edge}()},
\code{\link{forbid_tier_violations}()},
\code{\link{get_tiers}()},
\code{\link{remove_edges}()},
\code{\link{remove_tiers}()},
\code{\link{remove_vars}()},
\code{\link{reorder_tiers}()},
\code{\link{reposition_tier}()},
\code{\link{require_edge}()},
\code{\link{seq_tiers}()},
\code{\link{unfreeze}()}
}
\concept{knowledge}
\concept{knowledge functions}
